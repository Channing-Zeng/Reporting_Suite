---
title: "RNASeq QC report"
output: html_document
---

```{{r Load_Libraries, include=FALSE}}

library("ggplot2")
library(DESeq2)
library("RColorBrewer")
library("gplots")
library(amap)
library(pheatmap)
library(reshape2)

```
This report provides summaries and visualisations of QC metrics from an RNA-Seq dataset to assess the effect of any technical artefacts and to identify outlier samples.


```{{r Read_data, include=FALSE}}

ssFile = "{bcbio_csv}"
meta <- read.csv(ssFile, stringsAsFactors=F, header=T)
rownames(meta) <- meta$description
if(!is.element("condition", colnames(meta))){{
  meta <- data.frame(meta, condition1=rep("group1", nrow(meta)), condition2=meta$description)
}} else {{
  meta <- data.frame(meta, condition1=meta$condition, condition2=meta$condition)
}}

qcFile <- "{project_summary}"
qcDat <-  read.delim(qcFile, header=TRUE, stringsAsFactors=FALSE, sep="\t")
qcDat <- cbind(rownames(qcDat), qcDat)
colnames(qcDat) <- colnames(qcDat)[2:ncol(qcDat)]
qcDat <- qcDat[,1:ncol(qcDat)-1]
qcDat <- qcDat[rownames(meta),]
qcDat <- data.frame(qcDat, condition=meta$condition1)
qcDat <- qcDat[order(qcDat$condition),]
qcDat$Mapped.reads.pct = as.numeric(gsub("%", "", qcDat$Mapped.reads.pct))

doDisambig = FALSE
if(length(colnames(qcDat)[grep("Disambiguated", colnames(qcDat))])>0){{
  doDisambig=TRUE
}}

```
# Sequencing Depth

The below plot shows the numbers of reads obtained for each sample. For a set of samples that have come from the same multiplexed library we should expect similar numbers of reads for each sample. Large differences in numbers might indicate issues during the library preparation process. Whilst large differences in read numbers may be controlled for in downstream processings (e.g. read count normalisation), you may wish to consider whether the read depths achieved have fallen below recommended levels depending on the applications (e.g. ~ 10 million reads for differential gene expression analysis.) If disambiguation (see below) was used these rates are only reflective of the component that was assigned to the primary species (typically human) and not the whole sequencing depth. 

```{{r Seq_Depth, echo=FALSE, cache=FALSE}}
ggplot(qcDat, aes(x=Sample, y=Total.reads/1e6,fill= factor(condition))) +
  geom_bar(stat = 'identity') +
  ylab("Million reads") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  guides(fill=guide_legend(title="Condition"))

```

# Alignment Rates

The barplot below shows the percentages of reads for each sample that align to the reference genome. A high-quality RNA-Seq library should have ~95% of reads align. Low alignment rates could indicate contamination of samples (e.g. adapter sequences), low sequencing quality or other artefacts. These can be further investigated in the sequence level QC (e.g. from FastQC). The horizontal line indicates the median alignment rate for the full set of samples. If disambiguation (see below) was used, these percentages reflect fully aligned read pairs assigned to the primary species; if the percentage is not 100%, the lack is reflective of read pairs where one mate didn't align.

```{{r Aln_Rate, echo=FALSE, cache=FALSE}}
ggplot(qcDat, aes(x=Sample,y=Mapped.reads.pct,fill= factor(condition))) +
  geom_bar(stat = 'identity') +
  ylab("% Mapped Reads") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  guides(fill=guide_legend(title="Condition"))+
  geom_hline(aes(yintercept=median(Mapped.reads.pct)), size=1, linetype=2)

```

# Disambiguation

When samples are at risk of cross-species contamination (e.g. those derived from PDXs), then it is useful to assess the proportions of reads per sample that are assigned to the different species involved. If the Disambiguate algorithm was run to assess this, the next plot should show this information.


```{{r Disambig, echo=FALSE, cache=FALSE, eval=doDisambig}}
dis <- data.frame(Sample=qcDat$Sample,
                  prop.table(as.matrix(qcDat[,colnames(qcDat)[grep("Disambiguated", colnames(qcDat))]]),1))
colnames(dis) <- gsub("Disambiguated.", "", colnames(dis))
colnames(dis) <- gsub(".reads", "", colnames(dis))
dis <- melt(dis, id.vars = "Sample")
ggplot(dis, aes(x = Sample, y = value, fill = variable)) +
  geom_bar(stat = "identity") +
  ylab("Proportion of mapped reads") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  guides(fill=guide_legend(title="Species"))

```

# GC rate

The following plot shows the percent GC content of reads from each of the samples. The horizontal lines reprsent the median and median +- 2*MAD of %GC content for all the samples in the dataset to help identify any samples that have %GC levels that are significantly different to the rest of the samples.

```{{r GC, echo=FALSE, cache=FALSE, warning=FALSE}}
ggplot(qcDat, aes(x=Sample,y=X.GC,fill= factor(condition))) +
  geom_bar(stat = 'identity') +
  ylab("% GC content") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  geom_hline(aes(yintercept=median(X.GC)), size=1)+
  geom_hline(aes(yintercept=median(X.GC)+2*mad(X.GC)), size=1, linetype=3)+
  geom_hline(aes(yintercept=median(X.GC)-2*mad(X.GC)), size=1, linetype=3)+
  guides(fill=guide_legend(title="Condition"))

```

# Genomic Locations

The plot belows showns the proportions of reads that align within genes (exonic and intronic
locations) and between genes (intergenic)

```{{r GenLoc, echo=FALSE, cache=FALSE, warning=FALSE}}
gloc <- data.frame(Sample=qcDat$Sample, Exonic=qcDat$Exonic.Rate,
                  Intronic=qcDat$Intronic.Rate, Intergenic=qcDat$Intergenic.Rate)
rownames(gloc) <- rownames(qcDat)
gloc <- melt(gloc, id.vars = "Sample")
ggplot(gloc, aes(x = Sample, y = value, fill = variable)) +
  geom_bar(stat = "identity") +
  ylab("Proportion of mapped reads") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  guides(fill=guide_legend(title="Location"))

```

# Ribosomal RNA rates

Depending on the library preparation methods used, the proportion of rRNA sequences should be quite low. If large proportions of rRNA sequences are seen, it is wise to consider if the
depth of the remaining sequences is sufficient for further analyses.

```{{r rRNA, echo=FALSE, cache=FALSE, warning=FALSE}}
ggplot(qcDat, aes(x=Sample,y=rRNA_rate*100, fill= factor(condition))) +
  geom_bar(stat = 'identity') +
  ylab("% rRNA sequences") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  guides(fill=guide_legend(title="Condition"))

```

# 5'-3' bias
Significant deviation of 5'/3' ratios from the value of 1 could indicate biases which may have been introduced during the library preparation, RNA degradation, etc.

```{{r 5_3_bias, echo=FALSE, cache=FALSE, warning=FALSE}}
ggplot(qcDat, aes(x=Sample,y=X5..3..bias, fill= factor(condition))) +
  geom_bar(stat = 'identity') +
  ylab("5'/3' ratio") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  guides(fill=guide_legend(title="Condition")) +
  geom_hline(aes(yintercept=1), size=1)

```


# Sample Clustering Analyses

This section describes QC analyses based on gene-level read counts obtained per sample using clustering techniques.
These are a family of unsupervised machine learning methods that allow visualisation of patterns within the data. These are very useful as quality assurance tools - for example we can assess if the patterns seen in the data represent biological phenotypes that we might expect, or unwanted technical artefacts that may need to be controlled
for in further analyses. These are also useful in identifying outlier samples.

```{{r GetCounts, echo=FALSE, cache=FALSE, warning=FALSE}}
metax <- data.frame(name=as.character(meta$description), condition=as.character(meta$condition2))
rownames(metax) <-  metax$name

countsx <- read.delim("{combined_counts}", header=F, stringsAsFactors = F)
rownames(countsx) <- countsx[,1]
colnames(countsx) <- countsx[1,]
countsx <- countsx[-1,-1]
countsx <- countsx[, rownames(metax)]
counts <- apply(countsx, 2, as.numeric)
rownames(counts) <- rownames(countsx)

dds <- DESeqDataSetFromMatrix(countData = counts, colData=metax, design= ~ condition)
rld <- rlog(dds)

```
Two of the most widely used clustering methods are provided below:

## Hierarchical clustering

The heatmap below shows the relationships between the different samples obtained by quantifying the dissimilarity between samples using the correlation distance metric.
[See the high resolution image](clustering.png)

```{{r Corr_Heatmap, echo=FALSE, cache=FALSE}}
sampleDists <- Dist(t(assay(rld)), method="correlation")
sampleDistMatrix <- as.matrix(sampleDists)
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix, clustering_distance_rows=sampleDists, annotation_col=metax,
         clustering_distance_cols=sampleDists, col=colors,  main="Inter-sample Correlation distance")
png("clustering.png", width=25, height=25, res=300, units='cm')
pheatmap(sampleDistMatrix, fontsize = 8, clustering_distance_rows=sampleDists, annotation_col=metax,
         clustering_distance_cols=sampleDists, col=colors,  main="Inter-sample Correlation distance")
dev.off()

```

## Principal Components Analysis

Principal Components Analysis (PCA) is a very popular method that is based on the principles of dimensional
reduction. Below is a PCA plot of the samples within the space of the first two principal components that explain the most variation in the data. These were calculated using the read counts of the top 1000 most variable genes within the dataset.
[See the high resolution image](pca.png)
```{{r PCA, echo=FALSE, cache=FALSE}}
data <- plotPCA(rld, intgroup=c("condition"), returnData=TRUE, ntop=1000)
write.table(data, "pca.tsv", sep="\t")
percentVar <- round(100 * attr(data, "percentVar"))
ggplot(data, aes(PC1, PC2, color=condition, label=rownames(data))) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + geom_text(size=2, color="black",hjust=-0, vjust=-0)
ggsave("pca.png", width = 10, height = 10)
```



