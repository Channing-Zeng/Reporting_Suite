#!/usr/bin/perl -w

use Getopt::Std;
use strict;

our ($opt_c, $opt_d, $opt_v, $opt_b, $opt_h, $opt_B, $opt_j, $opt_H, $opt_s, $opt_S);
Usage() unless( getopts( 'hHvsSc:d:b:B:j:' ) );
Usage() if ( $opt_h || $opt_H );

my @col = $opt_c ? getcols( $opt_c ) : (1);
my $del = $opt_d ? qr/$opt_d/ : qr/\t/;
@col = map { /^\d+$/ ? $_ - 1 : $_; } @col;
$opt_B = qr/$opt_B/ if ( $opt_B );
$opt_j = defined($opt_j) ? $opt_j : "\t";

while( <> ) {
    chomp;
    s/^\s+// if ( $opt_s );
    s/\s+$// if ( $opt_S );
    my @a = split( /$del/, $_, -1 );
    #next unless (@a[@col] );
    my @tmp = ();
    if ( $opt_v ) {
        my %col = map { ($_, 1); } @col;
	for(my $i = 0; $i < @a; $i++) {
	    next if ( $col{$i} );
	    push( @tmp, $a[$i] );
	}
    } else {
	foreach(@col) {
	    if ( /^\d+$/ ) {
		push( @tmp, $a[$_] );
	    } elsif ( /^NULL$/ ) {
		push( @tmp, "" );
	    } else {
		push( @tmp, $_ );
	    }
	}
    }
    @tmp = map { "$opt_b$_$opt_b"; } @tmp if ( $opt_b );
    @tmp = map { s/^$opt_B//; s/$opt_B$//; $_; } @tmp if ( $opt_B );
    print join( $opt_j, @tmp ), "\n";
}

sub Usage {
    print STDERR <<USAGE;
$0 [-hH] [-c columns] [-d delimeter] [-b boundary] files

  The program extracts given columns from a files.

  -c  Column number start from 1.  Multiple columns are concatenated with ":"
      Can also use .. for range.  Also accept strings, which will be used as is.
      However, if the string is NULL, it will print an empty string.
  -d  The delimeter to split the line.  Default to "\t"
  -b  The boundary char/string to be added for each value
  -B  The boundary char/string to be removed for each value
  -j  The string to join the columns in the output
  -v  Do not select columns specified by -c option
  -s  Strip the leading spaces
  -S  Strip the trailing spaces
USAGE
    exit(0);
}

sub getcols {
    my $c = shift;
    my @c = ();
    my @a = split( /:/, $c );
    foreach(@a) {
	if ( /^(\d+)\.\.(\d+)s(\d+)$/ ) {
	    for(my $i = $1; $i <= $2; $i += $3) {
	        push( @c, $i );
	    }
	} elsif ( /^(\d+)\.\.(\d+)$/ ) {
	    push( @c, ($1 .. $2) );
	} else {
	    push( @c, $_ );
	}
    }
    return @c;
}
